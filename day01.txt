
1.面向对象的特征和基本原则
    三大特征：继承、封装、多态（抽象）
    五大基本原则：单一职责原则、开放封闭原则、替换原则、依赖原则、接口分离原则

    封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
    继承，是子类自动共享父类数据和方法的机制，这是类之间的一种关系，提高了软件的可重用性和可扩展性。
    多态，体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。比如重载和重写就是多态性的体现
        要理解多态性，首先要知道什么是“向上转型”。
        我定义了一个子类Dog，它继承了Animal类，那么后者就是前者的父类。可以通过：
           Dog d = new Dog();  例化一个Dog对象。
        但当我这样定义时： Animal a = new Dog();它表示我定义了一个Animal类型的引用，指向新建的Dog类型的对象。由于Dog是继承自它的父类Animal，所以Animal类型的引用是可以指向Dog类型的对象的。因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。所以，父类引用只能调用父类中存在的方法和属性，不能调用子类的扩展部分；因为父类引用指向的是堆中子类对象继承的父类；同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。

    单一职责原则SRP(Single Responsibility Principle)，是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

    开放封闭原则OCP(Open－Close Principle)，一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

    替换原则(the Liskov Substitution Principle LSP)，子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

    依赖原则(the Dependency Inversion Principle DIP)，具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

    接口分离原则(the Interface Segregation Principle ISP)，模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

2.Java中类的划分
    Java 中类可分为以下三种：
        普通类：使用 class 定义且不含有抽象方法的类。
        抽象类：使用 abstract class 定义的类，它可以含有或不含有抽象方法。
        接口：使用 interface 定义的类

    上述三种类存在以下的继承规律：
        普通类可以继承（extends）普通类，可以继承（extends）抽象类，可以实现（implements）接口。
        抽象类可以继承（extends）普通类，可以继承（extends）抽象类，可以实现（implements）接口。
        接口只能继承（extends）接口。
		
	 Java 不支持多继承，但支持多重继承。
     一个普通类或一个抽象类，要么继承一个普通类，要么继承一个抽象类，即所谓的单继承。
     一个普通类或一个抽象类或一个接口，可以实现任意多个接口。
     一个普通类继承一个抽象类后，必须实现这个抽象类中定义的所有抽象（abstract）方法，否则就只能被定义为抽象类。
     一个普通类继承一个接口后，必须实现这个接口中定义的所有方法，否则就只能被定义为抽象类。
     抽象类继承抽象类，或者实现接口时，可以部分、全部或者完全不实现父类抽象类的抽象（abstract）方法或父类接口中定义的方法。

3. 重载（overloading）和重写（overriding）
    重载和重写都是针对方法的概念，在弄清楚这两个概念之前，我们先来了解一下什么叫方法的型构（signature）。
    型构: 指方法的组成结构，具体包括方法的名称和参数，涵盖参数的数量、类型以及出现的顺序，但是不包括方法的返回值类型，访问权限修饰符，以及 abstract、static、final 等修饰符。

    重写(overriding),是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！
    重载(overloading),是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

4.final, finally, finalize 的区别
    final 用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.
    finally 是异常处理语句结构的一部分，表示总是执行.
    finalize 是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.

5.int和Integer有什么区别
    int是java的一种基本数据类型,Integer是int的包装类
    Integer变量必须实例化后才能使用，而int变量不需要 
    Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。
    Integer的默认值是null，int的默认值是0

6.说说反射的用途及实现
    在运行时判断任意一个对象所属的类；
    在运行时构造任意一个类的对象；
    在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；
    在运行时调用任意一个对象的方法
    重点：是运行时而不是编译时

    反射的实现:获取一个对象对应的反射类，在 Java 中有下列方法可以获取一个对象的反射类
        通过 getClass() 方法
        通过 Class.forName() 方法
        使用 类.class
        通过类加载器实现，getClassLoader()

7.说说自定义注解的场景及实现
https://www.yuque.com/gcdd1993/attau8/mikczx

8.HTTP 请求的 GET 与 POST 方式的



